import { defineComponent as u, defineAsyncComponent as P, resolveComponent as k, openBlock as o, createBlock as a, withCtx as l, renderSlot as m, resolveDynamicComponent as f, mergeProps as b, normalizeProps as B, createElementBlock as g, Fragment as $, renderList as v, createCommentVNode as W } from "vue";
import { d as h, B as S, w as y } from "./index-6f7aS4as.js";
import { a as C, g as A } from "./get-block-properties-XqAwKEib.js";
const R = () => import("./awaiter-niFBXKBm.js").then((e) => e.default).catch((e) => {
  throw console.error(
    "Error while attempting to dynamically import component Awaiter at ../../awaiter.vue",
    e
  ), e;
}), E = u({
  name: "interactive-element",
  components: { Awaiter: P(R) },
  props: ["includeBlockProps", "block", "context", "Wrapper", "wrapperProps"],
  computed: {
    attributes() {
      return this.includeBlockProps ? {
        ...C({
          block: this.block,
          context: this.context
        }),
        ...A({
          block: this.block,
          rootState: this.context.rootState,
          rootSetState: this.context.rootSetState,
          localState: this.context.localState,
          context: this.context.context
        })
      } : {};
    }
  }
});
function I(e, n, s, i, r, c) {
  const t = k("Awaiter");
  return e.Wrapper.load ? (o(), a(t, {
    key: 0,
    load: e.Wrapper.load,
    fallback: e.Wrapper.fallback,
    props: e.wrapperProps,
    attributes: e.attributes
  }, {
    default: l(() => [
      m(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["load", "fallback", "props", "attributes"])) : (o(), a(f(e.Wrapper), b({
    key: 1,
    attributes: e.attributes
  }, e.wrapperProps), {
    default: l(() => [
      m(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["attributes"]));
}
const d = /* @__PURE__ */ h(E, [["render", I]]), O = ({
  componentOptions: e,
  builderBlock: n,
  context: s,
  componentRef: i,
  includeBlockProps: r,
  isInteractive: c,
  contextValue: t
}) => {
  const p = {
    ...e,
    /**
     * If `noWrap` is set to `true`, then the block's props/attributes are provided to the
     * component itself directly. Otherwise, they are provided to the wrapper element.
     */
    ...r ? {
      attributes: C({
        block: n,
        context: t
      })
    } : {}
  };
  return c ? {
    Wrapper: i,
    block: n,
    context: s,
    wrapperProps: e,
    includeBlockProps: r
  } : p;
}, U = u({
  name: "component-ref",
  components: { Block: S, InteractiveElement: d },
  props: [
    "componentOptions",
    "blockChildren",
    "isInteractive",
    "componentRef",
    "builderBlock",
    "context",
    "linkComponent",
    "includeBlockProps",
    "registeredComponents"
  ],
  data() {
    return {
      shouldUpdate: !1,
      Wrapper: this.isInteractive ? y(d) : this.componentRef,
      getWrapperProps: O
    };
  },
  watch: {
    onUpdateHook0: { handler() {
    }, immediate: !0 }
  },
  computed: {
    onUpdateHook0() {
      return {
        0: this.componentOptions,
        1: this.blockChildren
      };
    }
  }
});
function H(e, n, s, i, r, c) {
  const t = k("Block");
  return e.componentRef ? (o(), a(f(e.Wrapper), B(b(
    { key: 0 },
    e.getWrapperProps({
      componentOptions: e.componentOptions,
      builderBlock: e.builderBlock,
      context: e.context,
      componentRef: e.componentRef,
      linkComponent: e.linkComponent,
      includeBlockProps: e.includeBlockProps,
      isInteractive: e.isInteractive,
      contextValue: e.context
    })
  )), {
    default: l(() => [
      (o(!0), g($, null, v(e.blockChildren, (p, w) => (o(), a(t, {
        key: p.id,
        block: p,
        context: e.context,
        registeredComponents: e.registeredComponents,
        linkComponent: e.linkComponent
      }, null, 8, ["block", "context", "registeredComponents", "linkComponent"]))), 128))
    ]),
    _: 1
  }, 16)) : W("", !0);
}
const F = /* @__PURE__ */ h(U, [["render", H]]);
export {
  F as default
};
